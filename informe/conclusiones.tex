\section{Conclusiones}

La pr\'{a}ctica nos ha servido para utilizar al mismo tiempo, muchos de los
recursos que hemos aprendido durante el curso ya que ha sido optimizar c\'{o}digo
de una aplicaci\'{o}n real. 

El hecho de tener que mirarse una aplicaci\'{o}n ya hecha, nos ha servido para
aprender a analizar un c\'{o}digo que est\'{a} formado por muchos m\'{o}dulos y muchas funciones
no hechas por nosotros. Esto, a\~{n}ade bastante dificultad al problema al tener que mirar
una por una, e imaginarnos c\'{o}mo est\'{a} estructurado el programa. El profiling
nos ha permitido empezar a optimizar la aplicaci\'{o}n, sin conocer la
estructura del c\'{o}digo, ni saber como funcionaba realmente la aplicaci\'{o}n.

Nos hemos encontrado con partes del programa que no pod\'{i}amos optimizar como
uviesemos querido ya que las intrinsecas que nos uvieran gustado utilizar,
no existian.

Tambi\'{e}n hemos aprendido que vectorizar funciones, no siempre implica
mejorar el rendimiento ya que el coste de cargar y descargar los registros
vectoriales, es elevado.

El hacer un programa orientado a una arquitectura en concreto
puede ser muy tedioso para aplicaciones que se hayan de utilizar en PC ya
que para cada tipo de arquitectura y versi\'{o}n de CPU, se ha de crear un
c\'{o}digo diferente. 
Provablemente optimizaciones como las que hemos aprendido a realizar, se
utilizan en aplicaciones de c\'{a}lculo intenso, o en aplicaciones que se sabe
en qu\'{e} arquitectura se van a ejecutar.

La asignatura nos ha hecho ver lo importante que es un compilador para crear
c\'{o}digo optimizado, y lo importante que \'{e}s conocer bien la arquitectura en
la que se va a ejecutar un c\'{o}digo para obtener un mayor rendimiento. 

Como curiosidad, decir que esta asignatura nos ha acabado de dejar claro
que el rendimiento del procesador no viene dado solo por lo r\'{a}pido que
ejecuta las instrucciones, sin\'{o} que el conjunto de instrucciones
soportadas, es igual de importante.

% vim: filetype=tex tw=75

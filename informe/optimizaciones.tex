\section{Optimizaciones}

La metodolog\'{i}a utilizada para llevar a cabo las optimizaciones es un
proceso iterativo que incluye los siguientes pasos en cada iteraci\'{o}n:

\begin{itemize}
\item Identificar la parte del c\'{o}digo que consume m\'{a}s tiempo
\item Realizar una optimizaci\'{o}n
\item Comprobar que la optimizaci\'{o}n mejora el rendimiento del programa
\end{itemize}

Utilizando la herramienta \texttt{gprof} se han identificado las partes del
c\'{o}digo original que consumen la mayor\'{i}a del tiempo de ejecuci\'{o}n.
La salida proporcionada por dicha herramienta es la siguiente:


En consecuencia, el objetivo de la primera optimizaci\'{o}n es la funci\'{o}n
\texttt{electric\_field}.

\subsection{Opt1: Evitar llamadas a funciones}

Las llamadas a funciones son un tipo de instrucci\'{o}n costosa que conviene
evitar siempre que sea posible. Algunas de las t\'{e}cnicas m\'{a}s comunes
para evitar llamadas a funciones son el inlining, la memorizaci\'{o}n o la
substituci\'{o}n de la llamada por un valor igual al valor de retorno.
\'{E}sta \'{u}ltima t\'{e}cnica es la que se puede utilizar para evitar llamar
a la funci\'{o}n \texttt{gaddress}.

La funci\'{o}n \texttt{gaddress} se encarga de calcular un \'{i}ndice de un
vector a partir de los cuatro par\'{a}metros que recibe. En el c\'{o}digo de
\texttt{electric\_field} se llama a la funci\'{o}n \texttt{gaddress} en
muchas ocasiones de forma innecesaria. La llamada es innecesaria porque la
secuencia de valores de retorno que generan las llamadas a \texttt{gaddress}
en el c\'{o}digo original es 0, 1, 2, ..., grid\_size-1, grid\_size+2,
grid\_size+3, etc. El c\'{o}digo original es el siguiente:

\begin{lstlisting}[]
     for( x = 0 ; x < grid_size ; x ++ ) {
        for( y = 0 ; y < grid_size ; y ++ ) {
           for( z = 0 ; z < grid_size ; z ++ ) {
              grid[gaddress(x,y,z,grid_size)] = ...
           }
        }
     }
\end{lstlisting}

La optimizaci\'{o}n propuesta consiste en cambiar la llamada a
\texttt{gaddress} por un simple contador que se incrementa en uno en cada
iteraci\'{o}n sobre \texttt{z} y en dos en cada iteraci\'{o}n sobre
\texttt{y}, generando as\'{i} los \'{i}ndices correctamente. El c\'{o}digo
resultante es el siguiente:

\begin{lstlisting}[]
     i = 0;
     for( x = 0 ; x < grid_size ; x ++ ) {
        for( y = 0 ; y < grid_size ; y ++ ) {
           for( z = 0 ; z < grid_size ; z ++ ) {
              grid[i] = ...
              i++;
           }
           i += 2;
        }
     }
\end{lstlisting}

Esta optimizaci\'{o}n se ha aplicado de la misma forma en otros puntos, como en
\texttt{electric\_field\_zero\_core} o en el primer bucle de
\texttt{electric\_point\_charge}.

\subsection{Opt2: Evitar saltos}

Los saltos, como las llamadas a funciones, son instrucciones que pueden llegar
a ser muy costosas debido a  los posibles fallos del predictor de saltos, por
eso es conveniente evitar los saltos innecesarios.

En el bucle m\'{a}s interno de la funci\'{o}n \texttt{electric\_field} hay
varias comprobaciones que se traducen en saltos al compilar. Adem\'{a}s, muchos
de estas comprobaciones son innecesarias u optimizables.

La primera l\'{i}nea del cuerpo del bucle es una comprobaci\'{o}n de que un
cierto valor es distinto de cero, pero lo cierto es que la comprobaci\'{o}n es
in\'{u}til. Si el valor es distinto de cero, se hacen una serie de c\'{a}lculos
y se acumula sobre una variable el resultado de dividir el valor por el
resultado de los c\'{a}lculos.

\begin{lstlisting}[]
     if( This_Structure.Residue[residue].Atom[atom].charge != 0 ) {
        ...
        phi += ( This_Structure.Residue[residue].Atom[atom].charge / ... ) ;
     }
\end{lstlisting}

Esta condici\'{o}n se puede eliminar ya que la ejecuci\'{o}n no cambia si
\texttt{This\_Structure.Residue[residue].\\Atom[atom].charge} es distinto de
cero y, si es cero, el resultado de divisi\'{o}n es cero y
\texttt{phi} se incrementa cero, haciendo que el resultado final sea correcto.
El problema es que el coste de hacer siempre este c\'{a}lculo es mayor que los
beneficios que supone ahorrarse la evaluaci\'{o}n de la condici\'{o}n y las
posibles penalizaciones 
por fallos del predictor de saltos, as\'{i} que la eleminaci\'{o}n no se ha
llevado a cabo.

Otra serie de sentencias condicionales que se puede simplificar es:

\begin{lstlisting}[]
     if( distance < 2.0 ) distance = 2.0 ;
     if( distance >= 2.0 ) {
        if( distance >= 8.0 ) {
           epsilon = 80 ;
        } else {
           if( distance <= 6.0 ) {
              epsilon = 4 ;
           } else {
              epsilon = ( 38 * distance ) - 224 ;
           }
        }
        phi += (This_Structure.Residue[residue].Atom[atom].charge/(epsilon*distance));
     }
\end{lstlisting}

La segunda comprobaci\'{o}n se puede eliminar ya que siempre se cumple debido a
la asignaci\'{o}n de la l\'{i}nea anterior. Adem\'{a}s, la secuencia de
condicionales imbricados para asignar un valor a \texttt{epsilon} se puede
simplificar. El c\'{o}digo resultante es:

\begin{lstlisting}[]
     if( distance < 2.0 ) distance = 2.0 ;
     if (distance >= 8.0)
        epsilon = 80;
     else if (distance <= 6.0)
        epsilon = 4;
     else
        epsilon = 38 * distance - 224;
     phi += (This_Structure.Residue[residue].Atom[atom].charge/(epsilon*distance));
\end{lstlisting}

Otra fuente de saltos innecesarios es el primer bucle de la funci\'{o}n
\texttt{electric\_field}. El c\'{o}digo original es:

\begin{lstlisting}
     i = 0;
     for( x = 0 ; x < grid_size ; x ++ ) {
        for( y = 0 ; y < grid_size ; y ++ ) {
           for( z = 0 ; z < grid_size ; z ++ ) {
              grid[i] = (fftw_real)0;
              i++;
           }
           i += 2;
        }
     }
\end{lstlisting}

Como se puede observar, los bucles sobre \texttt{x} e \texttt{y} se pueden
fusionar en uno solo y as\'{i} evitar un salto. El resulado es el siguiente
c\'{o}digo:

\begin{lstlisting}
     i = 0; 
     j = 0;
     while( j < grid_size*grid_size*grid_size) {
        for( i = j ; i < j+grid_size ; i ++ ) {
           grid[i] = (fftw_real)0;
        }
        j += grid_size + 2;
     }
\end{lstlisting}

Esta optimizaci\'{o}n se ha aplicado de la misma forma en otros puntos, como en
\texttt{electric\_field\_zero\_core} o en el primer bucle de
\texttt{electric\_point\_charge}.

\subsection{Opt3: Evitar llamadas a sistema}

Las llamadas a sistema son un tipo de instrucci\'{o}n especialmente costoso, ya
que provocan tener que entrar a modo sistema, salvar el contexto, ensuciar la
cache, etc. La tecnica m\'{a}s utilizada para evitar llamadas a sistema es el
buffering, o juntar varias llamadas a sistema en una.

En cada iteraci\'{o}n del bucle m\'{a}s externo del cuerpo de
\texttt{electric\_field} se hace un \texttt{printf(".")}. Esto provoca que
la ejecuci\'{o}n se hagan \texttt{grid\_size} \texttt{printf}'s que escriben un
solo punto, cuando lo \'{o}ptimo es hacer un solo \texttt{printf} que escriba
\texttt{grid\_size} puntos.

\subsection{Opt4: Unrolling}

El unrolling es una t\'{e}cnica que consiste en replicar el c\'{o}digo de un
bucle N veces para as\'{i} reducir el n\'{u}mero de saltos que se realizan al
ejecutar el c\'{o}digo de control del bucle. El n\'{u}mero de saltos se divide
por N.

En el c\'{o}digo original el bucle m\'{a}s interno se hace de esta forma:

\begin{lstlisting}
     for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
        cuerpo
     }
\end{lstlisting}

El unrolling realizado es de grado 4, es decir, se replica el cuerpo 4 veces y
se incrementa la variable \texttt{atom} en 4 en vez de en 1. Puede pasar que el
n\'{u}mero de iteraciones no sea divisible por 4, por eso hay que dividir el
bucle en dos. En el pre\'{a}mbulo se ejecutan iteraciones hasta que el
n\'{u}mero de iteraciones restante sea divisible por 4, y en el bucle principal
se hace el unrolling. El c\'{o}digo resultante es el siguiente:

\begin{lstlisting}
     num_non_unrolled_iters = This_Structure.Residue[residue].size % 4;
     for( atom = 1 ; atom <= num_non_unrolled_iters ; atom ++ ) {
        cuerpo
     }
     for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom +=4 ) {
        cuerpo0
        cuerpo1
        cuerpo2
        cuerpo3
     }
\end{lstlisting}

\subsection{Opt5: Vectorizaci\'{o}n}

Una vez el 


\subsection{OptA: Vectorizaci\'{o}n ineficiente}

En la funci\'{o}n \texttt{pythagoras} se calcula la dist\'{a}ncia euclidea
entre dos vectores. Para calcularla, se ejecutan tres instrucciones: una 
resta de componentes, una exponencial cuadrada, una suma de cada una de las
componentes, y la raiz cuadrada de esta suma.

\begin{lstlisting}
	sqrt( 
		( ( x1 - x2 ) * ( x1 - x2 ) ) 
		+ 
		( ( y1 - y2 ) * ( y1 - y2 ) ) 
		+ 
		( ( z1 - z2 ) * ( z1 - z2 ) ) 
		) ;
\end{lstlisting}

La transformaci\'{o}n de esta funci\'{o}n a vectorial, es bastante inmediata:

\begin{lstlisting}
	__m128 v1 = _mm_set_ps(x1, y1, z1, 0);
	__m128 v2 = _mm_set_ps(x2, y2, z2, 0);
	
	v1 = _mm_sub_ps(v1, v2);
	v1 = _mm_mul_ps(v1, v1);
	
	_mm_storeu_ps(vector, v1);
	
	sqrt(vector[1]+vector[2]+vector[3]);
\end{lstlisting}

Como vemos en el codigo anterior, a la hora de cargar los valores al
registro vectorial, tenemos que rellenar el \'{u}ltimo con algun valor
aunque no lo vayamos a utilizar.

En este trozo de c\'{o}digo, solo hacemos dos operaciones vectoriales
que s\'{o}n una suma i una multiplicaci\'{o}n, y adem\'{a}s, de los cuatro
valores, solo vamos a utilizar tres. Estos dos motivos, junto con que para
trabajar con las operaciones vectoriales necesitamos hacer el load hacia 
el registro vectorial, y el store hacia el registro no vectorial, hacen que
nuestra mejora, no sea una mejora, sin\'{o} que empeore el rendimiento de
la aplicaci\'{o}n.

\subsection{OptB: Uso de SSE3}

Al ver que la funci\'{o}n pythagoras era la m\'{a}s ejecutada, y la que
m\'{a}s tiempo consumia en total, nos hemos visto obligados a intentar
salvar el problema del coste que tiene hacer un load y un store a un
registro vectorial para hacer solo dos operaciones. Es por ese motivo que
hemos intentado a\~{n}adir m\'{a}s operaciones vectoriales, y eliminar los
accesos a mem\'{o}ria.

Para hacer esto, hemos usado operaciones a\'{u}n no utilizadas por nosotros,
como s\'{o}n las SSE3

\begin{lstlisting}
	float result;
	
	__m128 v1 = _mm_set_ps(x1, y1, z1, 0);
	__m128 v2 = _mm_set_ps(x2, y2, z2, 0);
	
	v1 = _mm_sub_ps(v1, v2);
	v1 = _mm_mul_ps(v1, v1);

	v1 = _mm_hadd_ps(v1, v1);
	v1 = _mm_hadd_ps(v1, v1);
	v1 = _mm_sqrt_ss(v1);	
	
	_mm_store_ss(&result, v1);
\end{lstlisting}

Podemos ver que hemos utilizado el intrinseco \texttt{\_mm\_hadd\_ps} dos
veces para ahorrarnos las sumas, y el intrinseco \texttt{\_mm\_sqrt\_ss} para
calcular la raiz cuadrada de la suma anterior. De esta forma, al tener que
recuperar solo un \texttt{float} del registro vectorial, hemos podido usar
el intrinseco \texttt{\_mm\_store\_ss} i as\'{i} ahorrarnos accesos a
mem\'{o}ria.

Para poder utilizar estas nuevas intrinsecas, ha sido necesario utilizar el
flag -msse3 del gcc.

\subsection{OptC: Inlineing}

Viendo que el principal penalizador para nuestra funci\'{o}n
\texttt{pythagoras} eran los accesos a mem\'{o}ria, y estudiando un poco el
origen de la mayor\'{i}a de las llamadas a esta funci\'{o}n, hemos visto
que hav\'{i}an parametros que cada vez se pasaban sin ser modificados. Esto
provocaba el tener que cargarlos en un registro vectorial, cuando ya
podr\'{i}an haber estado cargados de la ejecuci\'{o}n anterior.

\begin{lstlisting}
	distance = pythagoras(This_Structure.Residue[residue].Atom[atom].coord[1], 
						  This_Structure.Residue[residue].Atom[atom].coord[2], 
						  This_Structure.Residue[residue].Atom[atom].coord[3],
						  x_centre, y_centre, z_centre);
\end{lstlisting}
 
En el fichero \texttt{electrostatics.c} podemos ver que los parametros
\texttt{x\_centre}, \texttt{y\_centre} y \texttt{z\_centre} no canvian a cada
iteraci\'{o}n del bucle, sin\'{o} que se mantienen fijos durante muchas
iteraciones. Por este motivo, si hacemos inlineing, podemos llegar a
utilizar esto, y cargar el registro vectorial cuando se modifique uno de
estos valores.

Si lo hacemos as\'{i}, obtenemos el siguiente c\'{odigo}:

\begin{lstlisting}
	z_centre  = gcentre( z , grid_span , grid_size ) ;
	__m128 v2 = _mm_set_ps(x_centre, y_centre, z_centre, 0);
	phi = 0 ;
	for( residue = 1 ; residue <= This_Structure.length ; residue ++ ) {
		for( atom = 1 ; atom <= This_Structure.Residue[residue].size ; atom ++ ) {
			if( This_Structure.Residue[residue].Atom[atom].charge != 0 ) {
				__m128 v1 = _mm_set_ps(This_Structure.Residue[residue].Atom[atom].coord[1],
						This_Structure.Residue[residue].Atom[atom].coord[2],
						This_Structure.Residue[residue].Atom[atom].coord[3], 0);
				v1 = _mm_sub_ps(v1, v2);
				v1 = _mm_mul_ps(v1, v1);
				v1 = _mm_hadd_ps(v1, v1);
				v1 = _mm_hadd_ps(v1, v1);
				v1 = _mm_sqrt_ss(v1);	
				_mm_store_ss(&distance, v1);
\end{lstlisting}


\subsection{Ayuda}

Peque\~{n}a ayuda (mirar optimizaciones.tex para ver el c\'{o}digo):

Como poner una lista de elementos:
\begin{itemize}
   \item Elemento 1
   \item Elemento 2
\end{itemize}

Como poner una figura:
\begin{figure}[ht]
   \centering
   \includegraphics[keepaspectratio=true,width=.6\textwidth]{figures/muestra}
\end{figure}

Como poner una tabla:
\begin{center}
   \begin{tabular}{| c || c | c | c |}
      \hline
      	           & Load	& Store		& Total		\\ \hline \hline
	Accesses   & 105353	& 21423		& 126776	\\ \hline
	Hits       &  11644	&  1837		&  13481	\\ \hline
	Misses     &  93709 	& 19586		& 113295	\\ \hline
	Miss rate  & 88.95\%	& 91.43\%	& 89.37\%	\\ \hline
   \end{tabular}
\end{center}

% vim: filetype=tex tw=75
